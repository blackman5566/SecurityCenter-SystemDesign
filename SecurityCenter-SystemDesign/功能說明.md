# 即時賽事賠率系統（iOS Take‑Home Assignment）

本專案是一個 **即時賽事賠率系統** 的架構與實作示範，重點不在 UI 視覺，而在 **高頻即時更新情境下的系統設計能力**，包含：

- 非同步事件流（類 WebSocket）
- thread‑safe 狀態管理（Single Source of Truth）
- 高頻更新下的 UI 局部刷新策略
- 清楚的依賴注入與可替換架構
- 單元測試鎖住關鍵設計不變量

本實作對齊 iOS Take‑Home Assignment 的核心評分點，並刻意以「可上線等級的設計骨架」為目標，而非一次性作業。

---

## 版本資訊（Releases）

- **v1.0.0（SwiftUI 版本）**
  - 以 SwiftUI 建立完整 UI Demo（MVVM + Store）
  - Swift Concurrency（async/await、AsyncStream、actor）作為核心非同步模型
  - 高頻更新下的 row‑level 更新策略（避免整頁 reload）
  - 依賴注入（Composition Root）與可替換推播來源（Mock / Real）
  - 單元測試覆蓋關鍵不變量（Store / Manager / Update pipeline）

- **v1.0.1（新增 UIKit 版本）**
  - 新增 **UIKit Demo App**（與 SwiftUI 並存），方便面試官以熟悉的 UI 技術驗證同一套核心設計
  - 兩個 UI 入口 **共用同一套 Domain / Data / Update pipeline**（OddsStoreActor、OddsManager、OddsUpdateManager…）
  - 透過 Xcode **Scheme** 直接切換執行目標：
    - `NetDemo`：SwiftUI App
    - `NetDemoUIKit`：UIKit App

> ✅ 重點：UIKit 版本是「額外的展示層」，核心架構不複製、不分叉，保持單一資料流與單一狀態來源。

---

## 如何執行（Run）

### 1) SwiftUI 版本（v1.0.0）
1. 使用 Xcode 開啟專案
2. 在左上角 Run 按鈕旁的 **Scheme 下拉選單** 選擇 `NetDemo`
3. Run

### 2) UIKit 版本（v1.0.1）
1. 使用 Xcode 開啟專案
2. 在左上角 Run 按鈕旁的 **Scheme 下拉選單** 選擇 `NetDemoUIKit`
3. Run

> 你可以把它想成「同一個系統、兩種 UI 殼」：  
> 面試官要看 SwiftUI → 跑 `NetDemo`；要看 UIKit → 跑 `NetDemoUIKit`。

---

## 架構總覽

整體採用以下設計原則：

- **MVVM 架構**
- **Single Source of Truth（Store）**
- **Composition Root（依賴注入）**
- **Swift Concurrency（async/await、AsyncStream、actor）**

### 資料流方向（單向）

```
Repository / WebSocket Source
            ↓
   OddsManager / OddsUpdateManager
            ↓
        OddsStoreActor
            ↓
      snapshot / changedIDs
            ↓
          ViewModel
            ↓
              UI（SwiftUI / UIKit）
```

此資料流確保：
- 狀態集中、來源唯一
- UI 僅為狀態投影，不直接處理同步或推播細節
- SwiftUI / UIKit 只在「最後一層」分歧，核心不分叉

---

## Swift Concurrency 使用場景

本專案選擇 **Swift Concurrency** 作為非同步核心模型，並明確對應不同使用情境。

### 1️⃣ 初始資料載入（async / await）

- `MatchRepository`、`OddsRepository` 提供 async API
- `OddsManager` 負責：
  1. 從 repository 取得初始資料
  2. 寫入 `OddsStoreActor`
  3. 再由 store 回傳 snapshot 給 UI 使用

**設計重點**：  
UI 初始化永遠只使用 store snapshot，避免資料分裂（Single Source of Truth）。

---

### 2️⃣ 即時賠率推播（AsyncStream + Task）

- `OddsUpdateSource.makeStream()` 回傳 `AsyncStream<[Odds]>`
- 每次事件代表「一批（batch）」賠率更新
- `OddsUpdateManager` 在背景 `Task` 中消費該 stream：
  - 套用更新至 store
  - 僅對外輸出「實際有變動的 matchIDs」

此模型非常適合：
- WebSocket / 長連線
- 高頻事件推播
- 可取消、可重啟的生命週期管理

---

### 3️⃣ UI Flush（節流，選用）

`OddsUpdateManager` 支援 UI flush 機制，可將短時間內多次更新合併後再通知 UI，用於降低高頻推播下的 UI 壓力。

---

### 為什麼本專案未使用 Combine 作為核心事件流？

- WebSocket / 推播本質是 **async sequence**
- `AsyncStream + Task` 對應模型更直覺
- thread‑safe 交由 `actor` 結構性保證
- 降低 reactive pipeline 帶來的複雜度與 debug 成本

> 但本專案 **仍可能在 UIKit 視圖層（例如通知 UI 更新、或橋接某些 UIKit 元件）使用到 Combine**。  
> 差異在於：**Domain 的即時事件流核心選擇 Concurrency，不強迫用 Combine 當主幹。**

---

## Thread‑safe 與資料一致性設計

### OddsStoreActor（Single Source of Truth）

- 所有賠率狀態僅存在於 `OddsStoreActor`
- 使用 `actor` 保證：
  - 同一時間只有一個寫入者
  - 不共享 mutable state
  - 不需手動 lock / queue

### 高頻更新最佳化（applyBatch）

`applyBatch` 在 actor 內部實作以下策略：

- **Coalesce**：同一批次內重複 matchID 僅保留最後一筆
- **Dedup**：新舊值相同視為 no‑op，不回報變動
- **只回傳 changedIDs**，避免 UI 白刷新

此設計確保在每秒多筆更新下仍能保持效能穩定。

---

## UI 與 ViewModel 綁定方式

### SwiftUI（Observation / 非 Combine 主幹）
- ViewModel 使用 `@Observable`
- View 使用 `@Bindable`
- 狀態變更自動觸發 UI 更新

```swift
@Bindable private var viewModel: MatchListViewModel
```

### UIKit（示意）
- UIKit 版本同樣以 ViewModel 作為狀態橋樑
- 由 ViewModel 驅動 table/collection 的局部刷新
-（若有需要）可在 UI 層使用 Combine / callback 做狀態觀察與綁定

> UIKit 版本的目標是：用熟悉的 UIKit 表層，驗證同一套「高頻更新」與「單一狀態來源」設計可以無痛套用。

---

## UI 局部更新策略（效能關鍵）

即時更新流程如下：

1. `OddsUpdateManager` 輸出 changedIDs
2. ViewModel 向 store 取得這些 ID 的最新 snapshot
3. 僅更新對應 row 的顯示狀態
4. **不進行整頁 reload**

此策略可在高頻更新下維持畫面流暢。

---

## 依賴注入（Composition Root）

- 所有依賴集中在 `AppCompositionRoot`
- 下層僅依賴 protocol，不自行 new 具體實作
- 可自由替換：
  - Mock / Real Repository
  - Mock / Real WebSocket Source

此設計讓系統在測試與未來擴充時風險最低。

---

## WebSocket 推播來源可替換設計

### OddsUpdateSource 抽象

```swift
protocol OddsUpdateSource {
    func makeStream() -> AsyncStream<[Odds]>
}
```

### MockWebSocketOddsUpdateSource
- 每次 `makeStream()` 視為一次連線 session
- 固定送出 N 批後 `finish()`，模擬斷線
- 在尚未接真 WebSocket 時即可驗證完整即時管線

### WebSocketOddsUpdateSource（真實版骨架）
- 僅負責：
  - 連線
  - 收訊
  - parse 成 `[Odds]`
  - yield 至 AsyncStream
- 不處理 store、flush、重連策略（交由 manager）

### 一鍵切換
```swift
oddsUpdateSource = MockWebSocketOddsUpdateSource(...)
// or
oddsUpdateSource = WebSocketOddsUpdateSource(url: ...)
```

切換推播來源時，**其餘層級完全不需修改**。

---

## AppEnvironment（效能與壓測參數集中管理）

本專案透過 `AppEnvironment` 集中管理即時賠率系統中「**可調整的環境參數**」，將更新頻率、單次更新量、UI 節流等效能相關設定收斂到單一位置，而不是散落在各個 Manager / ViewModel / UI 之中。

**設計目的：**
- 將「效能策略」與「業務邏輯」解耦（避免 hard-coded）
- 方便在不同環境（Mock / 測試 / 實際運行）快速調校參數
- 讓系統具備可控的壓力測試入口：先調參數 → 再觀察瓶頸

```swift
public struct AppEnvironment: Sendable {
    public var updatesPerSecond: TimeInterval
    public var maxUpdatesPerTick: Int
    public var enableUIFlush: Bool
    public var uiFlushInterval: TimeInterval
}
```

### 參數解釋

- `updatesPerSecond`
  - 控制推播事件頻率（例如每 1 秒一次，或 0.2 秒一次）
  - 用於模擬「高頻推播」並驗證整條 pipeline 在高負載下是否穩定

- `maxUpdatesPerTick`
  - 控制每次推播的最大賠率筆數（模擬單次大量更新）
  - 用於驗證 store 的 `applyBatch`（coalesce / dedup）在大量更新下仍能保持效能與一致性

- `enableUIFlush`
  - 將 UI 節流策略變成一級開關（策略可切換，而不是寫死在 manager / UI）
  - 方便在「Demo 穩定顯示」與「壓測觀察極限」兩種模式間快速切換

- `uiFlushInterval`
  - 定義 UI 通知的合併間隔
  - 將短時間內多次變更合併成較少次 UI 更新，降低高頻更新下的 UI 壓力

> 簡單說：`AppEnvironment` 讓本專案的即時系統行為在不同負載下是「可調整、可壓測、可觀察的」，  
> 而不是依賴接手的人去猜哪裡可以改、或必須改 code 才能調參數。

---

## 單元測試（Unit Tests）

本專案撰寫單元測試以鎖住「設計不變量」，而非僅驗證語法。

### OddsManagerTests
- 驗證初始賠率一定寫入 store
- UI 初始化只能使用 store snapshot

### OddsStoreActorTests
- coalesce：同批重複 matchID 合併
- dedup：無變動更新不回報
- snapshot 僅回傳存在的 IDs

### OddsUpdateManagerTests
- start() 冪等性（避免重複訂閱）
- stop() 停止後不再有事件
- flush 行為可預期（使用 ManualOddsUpdateSource，避免 time‑based flaky test）

---

## 整體總結（對齊作業評分重點）

- ✅ Swift Concurrency 建模即時事件流
- ✅ actor 結構性保證 thread‑safe
- ✅ 高頻更新效能最佳化（coalesce / dedup / flush）
- ✅ UI 局部更新，避免整頁 reload
- ✅ 清楚的依賴注入與可替換設計
- ✅ 單元測試鎖住關鍵設計不變量
- ✅ 追加 UIKit 版本（Scheme 一鍵切換），同一套核心設計可被不同 UI 技術驗證

---


## 作者（Author）

Allen Hsu（許佳豪）  
iOS Engineer / System‑Oriented Developer

> **學無止境。**  
>  
> 這份專案的目的不只是完成作業，而是持續練習「如何在複雜需求下做出更穩定、可維護的設計判斷」。  
>  
> 技術會演進、工具會更替，但我相信真正重要的是：  
> 對系統保持敬畏、對未知保持學習的彈性。這份專案的目標不是展示「用了多少技術」，  
> 而是展示 **在即時、高頻、可擴充系統中，如何做出穩定且可維護的設計判斷**。
